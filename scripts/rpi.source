RPI_DIR=$(realpath ~/.rpi)

rpimodel=$(tr -d '\0' 2>/dev/null < /proc/device-tree/model)

if echo "$rpimodel" | grep -v Raspberry >/dev/null; then

    ## functions on host PC ##

    rpiSetup() {
	local ip=$1
	local username=$2

	mkdir -p $RPI_DIR
	echo $ip > $RPI_DIR/rpi.ip
	echo $username > $RPI_DIR/rpi.username
	echo "${username}@${ip}" > $RPI_DIR/rpi.access

    }

    rpiGetAccess() {
	cat $RPI_DIR/rpi.access 2>/dev/null
    }

    rpirsyncTo() {
	local file=$1

	[ "$(rpiGetAccess)" == "" ] && return 1

	rsync -avH $file $(rpiGetAccess):~/$file
    }

    rpirsyncFrom() {
	local file=$1

	[ "$(rpiGetAccess)" == "" ] && return 1

	rsync -avH $(rpiGetAccess):~/$file $file
    }

    rpissh() {
	[ "$(rpiGetAccess)" == "" ] && return 1

	rsync -avH $(realpath $BASH_SOURCE) $(rpiGetAccess):~ >/dev/null

	if [ $# -eq 0 ]; then
	    # FIXME: Do I really need to source rpi.source... This is the case of interactive ssh anyways, so maybe I can leave it up to the user to do so...
	    #        Doing the whole backup restore does not work if the ssh session is aborted by the server, causing the source line to be present several times, and to not be removed. It could be possible to make sure that there is only one line, but the level of complexity increases, and it is not even sure that this avoid all possible error scenarios.
	    #        The backup restore also does not work if you have more than one client ssh'ing in. Then the second client will source rpi.source twice.
	    ssh $(rpiGetAccess) "cp ~/.bashrc ~/.bashrc_rpibackup && echo \"source ~/$(basename $BASH_SOURCE)\" >> ~/.bashrc"
	    ssh $(rpiGetAccess)
	    ssh $(rpiGetAccess) "mv ~/.bashrc_rpibackup ~/.bashrc"
	else
	    ssh $(rpiGetAccess) "source ~/$(basename $BASH_SOURCE) && $@"
	fi
    }

    rpiCapturePhoto() {
	local file=$1

	# have rpi take the photo
	rpissh "rpicam-still -o $file" >/dev/null 2>/dev/null || return 1
	# get it from rpi
	rpirsyncFrom $file >/dev/null 2>/dev/null || return 2
    }

    rpiCaptureVideo() {
	local file=$1
	local timeSec=$2

	# have rpi make a video
	rpissh "rpiCaptureVideo $file $timeSec" || return 1
	# get it from rpi
	rpirsyncFrom $file
    }

    rpiSchedVideoAddDaily() {
	local time=$1
	local durationSec=$2

	rpissh "rpiSchedVideoAddDaily $time $durationSec"
    }

    rpiSchedVideoListDaily() {
	rpissh "rpiSchedVideoListDaily"
    }

    rpiSchedVideoRemoveDaily() {
	local time=$1
	local durationSec=$2

	rpissh "rpiSchedVideoRemoveDaily $time $durationSec"
    }

    rpiSchedVideoRemoveAllDaily() {
	rpissh "rpiSchedVideoRemoveAllDaily"
    }

else

    ## functions on the Raspberry Pi ##

    RPICAM_FLOCK="$RPI_DIR/rpicam.flock"
    RPI_LOG="$RPI_DIR/rpi.log"

    mkdir -p $RPI_DIR

    rpiTest() {
	echo "rpiTest $@" >> $RPI_LOG
    }

    rpiLibcameravid() {
	flock -n $RPICAM_FLOCK libcamera-vid $@
	if [ $? -ne 0 ]; then
	    echo "failed to run libcamera-vid $@" >> $RPI_LOG
	fi
    }

    rpiCaptureVideo() {
	local file=$1
	local timeSec=$2

	rpiLibcameravid -t $(($timeSec * 1000)) --codec libav --libav-format mp4 -o $file
    }

    RPI_SCHED_VIDEO_CRON_FILE_PREFIX="/etc/cron.d/rpicam_"
    RPI_SCHED_VIDEO_DIR="rpi_sched_video"

    rpiSchedVideoCronFileName() {
	local time=$1
	local durationSec=$2

	local timeHours=${time%%:*}
	local timeMinutes=${time##*:}

	echo "${RPI_SCHED_VIDEO_CRON_FILE_PREFIX}${timeHours}_${timeMinutes}_${durationSec}"
    }

    rpiSchedVideoFileName() {
	local durationSec=$1

	echo "${RPI_SCHED_VIDEO_DIR}/$(date +rpicamvid_%Y_%m_%d_%h_%m_$durationSec).mp4"
    }

    rpiSchedVideoAddDaily() {
	local time=$1
	local durationSec=$2

	local videoFile=$(rpiSchedVideoFileName $durationSec)

	# make sure that the folder for scheduled videos exists
	mkdir -p $RPI_SCHED_VIDEO_DIR

	# setup cron job for recording video
	local timeHours=${time%%:*}
	local timeMinutes=${time##*:}

	local cronSchedule="$timeMinutes $timeHours * * *"
	
	local runningUser=$(whoami)
	echo "$cronSchedule $runningUser . ~/$(basename $BASH_SOURCE) >>$RPI_LOG 2>&1 && rpiCaptureVideo \$(rpiSchedVideoFileName $durationSec) $durationSec >>$RPI_LOG 2>&1" | sudo tee $(rpiSchedVideoCronFileName $time $durationSec) >/dev/null
    }

    rpiSchedVideoListDaily() {
	local filePrefix=$(basename ${RPI_SCHED_VIDEO_CRON_FILE_PREFIX})
	local fileDir=$(dirname ${RPI_SCHED_VIDEO_CRON_FILE_PREFIX})
	for filePath in $(find $fileDir -name "$filePrefix*" | sort); do
	    local fileName=$(basename $filePath)
	    local fileSuffix=${fileName#*_}
	    local timeHours=$(echo $fileSuffix | awk -F'_' '{print $1}')
	    local timeMinutes=$(echo $fileSuffix | awk -F'_' '{print $2}')
	    local durationSec=$(echo $fileSuffix | awk -F'_' '{print $3}')
	    printf "%2d:%02d %-6d -- $filePath: $(cat $filePath)\n" $timeHours $timeMinutes $durationSec
	done
    }

    rpiSchedVideoRemoveDaily() {
	local time=$1
	local durationSec=$2

	sudo rm $(rpiSchedVideoCronFileName $time $durationSec)
    }

    rpiSchedVideoRemoveAllDaily() {
	sudo rm ${RPI_SCHED_VIDEO_CRON_FILE_PREFIX}*
    }
fi

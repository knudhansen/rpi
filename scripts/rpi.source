RPI_DIR=$(realpath ~/.rpi)
RPI_SCHED_VIDEO_DIR="rpi_sched_video"
RPI_SOURCE_FILE=$(realpath $BASH_SOURCE)

rpimodel=$(tr -d '\0' 2>/dev/null < /proc/device-tree/model)

if echo "$rpimodel" | grep -v Raspberry >/dev/null; then

    ## functions on host PC ##

    rpiSetup() {
	local ip=$1
	local username=$2
	local key=${3:-rpi_rsa}

	mkdir -p $RPI_DIR
	echo $ip > ${RPI_DIR}/rpi.ip
	echo $username > ${RPI_DIR}/rpi.username
	echo $key > ${RPI_DIR}/rpi.key

	# if no rpi key present generate 1
	if [ ! -f ${RPI_DIR}/${key}.pub ]; then
	    ssh-keygen -f ${RPI_DIR}/${key} -t rsa -b 4096 -N "" >/dev/null
	fi

	# send the key to Raspberry Pi and concatenate the key to authorized_keys. This will request password on Raspberry Pi once.
	ssh $(rpiGetAccess) "touch ~/.ssh/authorized_keys && echo $(cat ${RPI_DIR}/${key}.pub) >> ~/.ssh/authorized_keys"
    }

    rpiGetAccess() {
	echo "$(cat ${RPI_DIR}/rpi.username)@$(cat ${RPI_DIR}/rpi.ip)" 2>/dev/null
    }

    rpiGetSshOptions() {
	echo "-i ${RPI_DIR}/$(cat ${RPI_DIR}/rpi.key)" 2>/dev/null
    }

    rpirsync() {
	local rsyncSrc=$1
	local rsyncDst=$2

	rsync -avH -e "ssh $(rpiGetSshOptions)" $rsyncSrc $rsyncDst
    }

    rpirsyncFrom() {
	local file=$1
	local hostDest=$2

	[ "$(rpiGetAccess)" == "" ] && return 1

	local serialNumber=$(rpiGetSerialNumber)
	mkdir -p ~/${serialNumber}
	rpirsync $(rpiGetAccess):~/$file ~/rpi_${serialNumber}/$file
    }

    rpissh() {
	[ "$(rpiGetAccess)" == "" ] && return 1

	rpirsync $RPI_SOURCE_FILE $(rpiGetAccess):~ >/dev/null || return 2

	if [ $# -eq 0 ]; then
	    # FIXME: Do I really need to source rpi.source... This is the case of interactive ssh anyways, so maybe I can leave it up to the user to do so...
	    #        Doing the whole backup restore does not work if the ssh session is aborted by the server, causing the source line to be present several times, and to not be removed. It could be possible to make sure that there is only one line, but the level of complexity increases, and it is not even sure that this avoid all possible error scenarios.
	    #        The backup restore also does not work if you have more than one client ssh'ing in. Then the second client will source rpi.source twice.
	    ssh $(rpiGetSshOptions) $(rpiGetAccess) "cp ~/.bashrc ~/.bashrc_rpibackup && echo \"source ~/$(basename $BASH_SOURCE)\" >> ~/.bashrc" || return 3
	    ssh $(rpiGetSshOptions) $(rpiGetAccess) || return 3
	    ssh $(rpiGetSshOptions) $(rpiGetAccess) "mv ~/.bashrc_rpibackup ~/.bashrc" || return 3
	else
	    ssh $(rpiGetSshOptions) $(rpiGetAccess) "source ~/$(basename $BASH_SOURCE) && $@"|| return 3
	fi
    }

    rpiGetSerialNumber() {
	rpissh "rpiGetSerialNumber"
    }

    rpiCapturePhoto() {
	local file=$1

	# have rpi take the photo
	rpissh "rpicam-still -o $file" >/dev/null 2>/dev/null || return 1
	# get it from rpi
	rpirsyncFrom $file >/dev/null 2>/dev/null || return 2
    }

    rpiCaptureVideo() {
	local file=$1
	local timeSec=$2

	# have rpi make a video
	rpissh "rpiCaptureVideo $file $timeSec" || return 1
	# get it from rpi
	rpirsyncFrom $file
    }

    rpiSchedVideoAddDaily() {
	local time=$1
	local durationSec=$2
	
	rpissh "rpiSchedVideoAddDaily $time $durationSec"
    }

    rpiSchedVideoListDaily() {
	rpissh "rpiSchedVideoListDaily"
    }

    rpiSchedVideoRemoveDaily() {
	local time=$1
	local durationSec=$2

	rpissh "rpiSchedVideoRemoveDaily $time $durationSec"
    }

    rpiSchedVideoRemoveAllDaily() {
	rpissh "rpiSchedVideoRemoveAllDaily"
    }

    rpiSchedVideoRetrieveRecordings() {
	mkdir -p $RPI_SCHED_VIDEO_DIR
	rpirsyncFrom ${RPI_SCHED_VIDEO_DIR}/
    }

    rpiSchedVideoDeleteRecordings() {
	rpissh "rm -rf ${RPI_SCHED_VIDEO_DIR}/*"
    }

    rpiSchedVideoListRecordings() {
	rpissh "find $RPI_SCHED_VIDEO_DIR -type f"
    }

else

    ## functions on the Raspberry Pi ##

    RPICAM_FLOCK="$RPI_DIR/rpicam.flock"
    RPI_LOG="$RPI_DIR/rpi.log"

    mkdir -p $RPI_DIR

    rpiTest() {
	echo "rpiTest $@" >> $RPI_LOG
    }

    rpiGetSerialNumber() {
	cat /proc/cpuinfo | grep Serial | cut -d ' ' -f 2
    }

    rpiLibcameravid() {
	flock -n $RPICAM_FLOCK libcamera-vid $@
	if [ $? -ne 0 ]; then
	    echo "failed to run libcamera-vid $@" >> $RPI_LOG
	fi
    }

    rpiCaptureVideo() {
	local file=$1
	local timeSec=$2

	rpiLibcameravid -t $(($timeSec * 1000)) --codec libav --libav-format mp4 -o $file
    }

    RPI_SCHED_VIDEO_CRON_FILE_PREFIX="/etc/cron.d/rpicam_"

    rpiSchedVideoCronFileName() {
	local scheduleId=$1

	echo "${RPI_SCHED_VIDEO_CRON_FILE_PREFIX}${scheduleId}"
    }

    rpiSchedVideoFileName() {
	local scheduleId=$1

	local durationSec=$(_rpiSchedGetDurationSec $scheduleId)
	echo "${RPI_SCHED_VIDEO_DIR}/${scheduleId}/$(date +rpicamvid_%Y_%m_%d_%H_%M_$durationSec).mp4"
    }

    _rpiSchedUserToId() {
	local time=$1
	local durationSec=$2

	echo "$(echo $time | tr ':' '_')_$durationSec"
    }

    _rpiSchedGetCronSchedule() {
	local scheduleId=$1

	echo $scheduleId | awk -F'_' '{print $2 " " $1 " * * *"}'
    }

    _rpiSchedGetStartTime() {
	local schedId=$1

	local time=$(echo $schedId | awk -F'_' '{printf $1 ":" $2}')
	date -d "$time" "+%s"
    }

    _rpiSchedGetDurationSec() {
	local schedId=$1

	echo $schedId | awk -F'_' '{print $3}'
    }

    _rpiSchedGetUser() {
        local schedId=$1

        local timeHours=$(echo $schedId | awk -F'_' '{print $1}')
        local timeMinutes=$(echo $schedId | awk -F'_' '{print $2}')
        local durationSec=$(echo $schedId | awk -F'_' '{print $3}')
        printf "%2d:%02d %d" $timeHours $timeMinutes $durationSec
    }

    # check overlaps. If no overlap, echos empty string, otherwise echos the latest of the 2 schedules
    _rpiSchedCheckOverlap() {
	local sched1Id=$1
	local sched2Id=$2

	local sched1Start=$(_rpiSchedGetStartTime $sched1Id)
	local sched1End=$(($sched1Start + $(_rpiSchedGetDurationSec $sched1Id)))
	local sched2Start=$(_rpiSchedGetStartTime $sched2Id)
	local sched2End=$(($sched2Start + $(_rpiSchedGetDurationSec $sched2Id)))

	# find max of start times
	local maxStartTime=$sched1Start
	local maxStartSched=$sched1Id # remembering which is the latest of the 2 schedules
	if [ $sched2Start -gt $maxStartTime ]; then
	    maxStartTime=$sched2Start
	    maxStartSched=$sched2Id
	fi
	# find min of end times
	local minEndTime=$sched1End
	if [ $sched2End -lt $minEndTime ]; then
	    minEndTime=$sched2End
	fi

	if [ $minEndTime -gt $maxStartTime ]; then
	    echo $maxStartSched
	fi
    }

    rpiSchedVideoAddDaily() {
	local time=$1
	local durationSec=$2

	# setup cron job for recording video
	local scheduleId=$(_rpiSchedUserToId $time $durationSec)

	# make sure that the folder for scheduled videos exists
	local scheduleDir=$(dirname $(rpiSchedVideoFileName $scheduleId))
	mkdir -p $scheduleDir

	local cronSchedule=$(_rpiSchedGetCronSchedule $scheduleId)
	
	local runningUser=$(whoami)

	local cronFileName=$(rpiSchedVideoCronFileName $scheduleId)

	# Fail on matching existing schedule
	ls $cronFileName >/dev/null 2>&1
	if [ $? -eq 0 ]; then
	    echo a video is already scheduled at time $time for duration $duration.
	    return 1
	fi

	for preExistingScheduleId in $(_rpiSchedUserToId $(rpiSchedVideoListDaily | awk '{print $1 " " $2}')); do
	    local nonExecutedScheduleId=$(_rpiSchedCheckOverlap $preExistingScheduleId $scheduleId)
	    if [ "$nonExecutedScheduleId" != "" ]; then
		echo "WARNING: Schedule overlaps with pre-existing schedule $(_rpiSchedGetUser $preExistingScheduleId). $(_rpiSchedGetUser $nonExecutedScheduleId) will not happen!"
	    fi
	done

	echo "$cronSchedule $runningUser . ~/$(basename $BASH_SOURCE) >>$RPI_LOG 2>&1 && rpiCaptureVideo \$(rpiSchedVideoFileName $scheduleId) $durationSec >>$RPI_LOG 2>&1" | sudo tee $cronFileName >/dev/null
    }

    rpiSchedVideoListDaily() {
	local filePrefix=$(basename ${RPI_SCHED_VIDEO_CRON_FILE_PREFIX})
	local fileDir=$(dirname ${RPI_SCHED_VIDEO_CRON_FILE_PREFIX})
	for filePath in $(find $fileDir -name "$filePrefix*" | sort); do
	    local fileName=$(basename $filePath)
	    local scheduleId=${fileName#*_}
	    printf "%-12s -- $filePath: $(cat $filePath)\n" "$(_rpiSchedGetUser $scheduleId)"
	done
    }

    rpiSchedVideoRemoveDaily() {
	local time=$1
	local durationSec=$2

	sudo rm $(rpiSchedVideoCronFileName $(_rpiSchedUserToId $time $durationSec))
    }

    rpiSchedVideoRemoveAllDaily() {
	sudo rm -f ${RPI_SCHED_VIDEO_CRON_FILE_PREFIX}*
    }
fi

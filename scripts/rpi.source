RPI_DIR=$(realpath ~/.rpi)
RPI_SCHED_VIDEO_DIR="rpi_sched_video"
RPI_SOURCE_FILE=$(realpath $BASH_SOURCE)

rpimodel=$(tr -d '\0' 2>/dev/null < /proc/device-tree/model)

if echo "$rpimodel" | grep -v Raspberry >/dev/null; then

    ## functions on host PC ##

    rpiSetup() {
	local ip=$1
	local username=$2
	local key=${3:-rpi_rsa}

	mkdir -p $RPI_DIR
	echo $ip > ${RPI_DIR}/rpi.ip
	echo $username > ${RPI_DIR}/rpi.username
	echo $key > ${RPI_DIR}/rpi.key

	# if no rpi key present generate 1
	if [ ! -f ${RPI_DIR}/${key}.pub ]; then
	    ssh-keygen -f ${RPI_DIR}/${key} -t rsa -b 4096 -N "" >/dev/null
	fi

	# send the key to Raspberry Pi and concatenate the key to authorized_keys. This will request password on Raspberry Pi once.
	ssh $(rpiGetAccess) "touch ~/.ssh/authorized_keys && echo $(cat ${RPI_DIR}/${key}.pub) >> ~/.ssh/authorized_keys"
    }

    rpiGetAccess() {
	echo "$(cat ${RPI_DIR}/rpi.username)@$(cat ${RPI_DIR}/rpi.ip)" 2>/dev/null
    }

    rpiGetSshOptions() {
	echo "-i ${RPI_DIR}/$(cat ${RPI_DIR}/rpi.key)" 2>/dev/null
    }

    rpirsync() {
	local rsyncSrc=$1
	local rsyncDst=$2

	rsync -avH -e "ssh $(rpiGetSshOptions)" $rsyncSrc $rsyncDst
    }

    rpirsyncFrom() {
	local file=$1
	local hostDest=$2

	[ "$(rpiGetAccess)" == "" ] && return 1

	local serialNumber=$(rpiGetSerialNumber)
	mkdir -p ~/${serialNumber}
	rpirsync $(rpiGetAccess):~/$file ~/rpi_${serialNumber}/$file
    }

    rpissh() {
	[ "$(rpiGetAccess)" == "" ] && return 1

	rpirsync $RPI_SOURCE_FILE $(rpiGetAccess):~ >/dev/null || return 2

	if [ $# -eq 0 ]; then
	    # FIXME: Do I really need to source rpi.source... This is the case of interactive ssh anyways, so maybe I can leave it up to the user to do so...
	    #        Doing the whole backup restore does not work if the ssh session is aborted by the server, causing the source line to be present several times, and to not be removed. It could be possible to make sure that there is only one line, but the level of complexity increases, and it is not even sure that this avoid all possible error scenarios.
	    #        The backup restore also does not work if you have more than one client ssh'ing in. Then the second client will source rpi.source twice.
	    ssh $(rpiGetSshOptions) $(rpiGetAccess) "cp ~/.bashrc ~/.bashrc_rpibackup && echo \"source ~/$(basename $BASH_SOURCE)\" >> ~/.bashrc" || return 3
	    ssh $(rpiGetSshOptions) $(rpiGetAccess) || return 3
	    ssh $(rpiGetSshOptions) $(rpiGetAccess) "mv ~/.bashrc_rpibackup ~/.bashrc" || return 3
	else
	    ssh $(rpiGetSshOptions) $(rpiGetAccess) "source ~/$(basename $BASH_SOURCE) && $@"|| return 3
	fi
    }

    rpiGetSerialNumber() {
	rpissh "rpiGetSerialNumber"
    }

    rpiCapturePhoto() {
	local file=$1

	# have rpi take the photo
	rpissh "rpicam-still -o $file" >/dev/null 2>/dev/null || return 1
	# get it from rpi
	rpirsyncFrom $file >/dev/null 2>/dev/null || return 2
    }

    rpiCaptureVideo() {
	local file=$1
	local timeSec=$2

	# have rpi make a video
	rpissh "rpiCaptureVideo $file $timeSec" || return 1
	# get it from rpi
	rpirsyncFrom $file
    }

    rpiSchedVideoAddDaily() {
	local time=$1
	local durationSec=$2
	
	rpissh "rpiSchedVideoAddDaily $time $durationSec"
    }

    rpiSchedVideoListDaily() {
	rpissh "rpiSchedVideoListDaily"
    }

    rpiSchedVideoRemoveDaily() {
	local time=$1
	local durationSec=$2

	rpissh "rpiSchedVideoRemoveDaily $time $durationSec"
    }

    rpiSchedVideoRemoveAllDaily() {
	rpissh "rpiSchedVideoRemoveAllDaily"
    }

    rpiSchedVideoRetrieveRecordings() {
	mkdir -p $RPI_SCHED_VIDEO_DIR
	rpirsyncFrom ${RPI_SCHED_VIDEO_DIR}/
    }

    rpiSchedVideoDeleteRecordings() {
	rpissh "rm -rf ${RPI_SCHED_VIDEO_DIR}/*"
    }

    rpiSchedVideoListRecordings() {
	rpissh "find $RPI_SCHED_VIDEO_DIR -type f"
    }

else

    ## functions on the Raspberry Pi ##

    RPICAM_FLOCK="$RPI_DIR/rpicam.flock"
    RPI_LOG="$RPI_DIR/rpi.log"

    mkdir -p $RPI_DIR

    rpiTest() {
	echo "rpiTest $@" >> $RPI_LOG
    }

    rpiGetSerialNumber() {
	cat /proc/cpuinfo | grep Serial | cut -d ' ' -f 2
    }

    rpiLibcameravid() {
	flock -n $RPICAM_FLOCK libcamera-vid $@
	if [ $? -ne 0 ]; then
	    echo "failed to run libcamera-vid $@" >> $RPI_LOG
	fi
    }

    rpiCaptureVideo() {
	local file=$1
	local timeSec=$2

	rpiLibcameravid -t $(($timeSec * 1000)) --codec libav --libav-format mp4 -o $file
    }

    RPI_SCHED_VIDEO_CRON_FILE_PREFIX="/etc/cron.d/rpicam_"

    rpiSchedVideoCronFileName() {
	local time=$1
	local durationSec=$2

	local timeHours=${time%%:*}
	local timeMinutes=${time##*:}

	echo "${RPI_SCHED_VIDEO_CRON_FILE_PREFIX}${timeHours}_${timeMinutes}_${durationSec}"
    }

    rpiSchedVideoFileName() {
	local scheduleId=$1
	local durationSec=$2

	echo "${RPI_SCHED_VIDEO_DIR}/${scheduleId}/$(date +rpicamvid_%Y_%m_%d_%H_%M_$durationSec).mp4"
    }

    rpiSchedVideoAddDaily() {
	local time=$1
	local durationSec=$2

	# setup cron job for recording video
	local timeHours=${time%%:*}
	local timeMinutes=${time##*:}
	local scheduleId=${timeHours}_${timeMinutes}_${durationSec}

	# make sure that the folder for scheduled videos exists
	local scheduleDir=$(dirname $(rpiSchedVideoFileName $scheduleId $durationSec))
	mkdir -p $scheduleDir

	local cronSchedule="$timeMinutes $timeHours * * *"
	
	local runningUser=$(whoami)

	local cronFileName=$(rpiSchedVideoCronFileName $time $durationSec)
	ls $cronFileName >/dev/null 2>&1
	if [ $? -eq 0 ]; then
	    echo a video is already scheduled at time $time for duration $duration.
	    return 1
	fi

	echo "$cronSchedule $runningUser . ~/$(basename $BASH_SOURCE) >>$RPI_LOG 2>&1 && rpiCaptureVideo \$(rpiSchedVideoFileName $scheduleId $durationSec) $durationSec >>$RPI_LOG 2>&1" | sudo tee $cronFileName >/dev/null
    }

    rpiSchedVideoListDaily() {
	local filePrefix=$(basename ${RPI_SCHED_VIDEO_CRON_FILE_PREFIX})
	local fileDir=$(dirname ${RPI_SCHED_VIDEO_CRON_FILE_PREFIX})
	for filePath in $(find $fileDir -name "$filePrefix*" | sort); do
	    local fileName=$(basename $filePath)
	    local fileSuffix=${fileName#*_}
	    local timeHours=$(echo $fileSuffix | awk -F'_' '{print $1}')
	    local timeMinutes=$(echo $fileSuffix | awk -F'_' '{print $2}')
	    local durationSec=$(echo $fileSuffix | awk -F'_' '{print $3}')
	    printf "%2d:%02d %-6d -- $filePath: $(cat $filePath)\n" $timeHours $timeMinutes $durationSec
	done
    }

    rpiSchedVideoRemoveDaily() {
	local time=$1
	local durationSec=$2

	sudo rm $(rpiSchedVideoCronFileName $time $durationSec)
    }

    rpiSchedVideoRemoveAllDaily() {
	sudo rm -f ${RPI_SCHED_VIDEO_CRON_FILE_PREFIX}*
    }
fi
